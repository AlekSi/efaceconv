package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
)

type EcUnit struct {
	Import     string
	Type       string
	CustomName string
}

func (e *EcUnit) GenerateImport() string {
	return fmt.Sprintf("%v", e.Import)
}

func (e *EcUnit) GenerateVarForTDPointer() string {
	return fmt.Sprintf("_%vKind uintptr", e.CustomName)
}

func (e *EcUnit) GenerateInit() string {
	return fmt.Sprintf("var s%v %v\n  _%[1]vKind = ecutils.GetKind(s%[1]v)", e.CustomName, e.Type)
}

const MethodTemplate = `
// Eface2%v returns pointer to %v and true if arg is a string
// or nil and false otherwise
func Eface2%[1]v(arg interface{}) (*%[2]v, bool) {
	if ecutils.GetKind(arg) == _%[1]vKind {
		return (*%[2]v)(ecutils.GetDataPtr(arg)), true
	}
	return nil, false
}

`

const TestTemplate = `
func TestEface2%v(t *testing.T) {
  var %[1]v  %v
	res, ok := Eface2%[1]v(%[1]v)
	if !ok {
		t.Error("Wrong type!")
	}
	if !reflect.DeepEqual(*res, %[1]v) {
		t.Error("Not equal")
	}
	_, ok = Eface2%[1]v(ok)
	if ok {
		t.Error("Wrong type!")
	}
}

`

const Benchmark = `
func BenchmarkEface2%v(b *testing.B) {
  var %[1]v %[2]v
	var v *%[2]v
	var ok bool
	for n := 0; n < b.N; n++ {
		v, ok = Eface2%[1]v(%[1]v)
	}
	b.Log(v, ok) //For don't use compiler optimization
}

func _%[1]vClassic(arg interface{}) (v %[2]v, ok bool) {
	v, ok = arg.(%[2]v)
	return v, ok
}

func Benchmark%[1]vClassic(b *testing.B) {
  var %[1]v %[2]v
  var v %[2]v
	var ok bool
	for n := 0; n < b.N; n++ {
		v, ok = _%[1]vClassic(%[1]v)
	}
	b.Log(v, ok) //For don't use compiler optimization
}


`

func (e *EcUnit) GenerateConvMethod() string {
	return fmt.Sprintf(MethodTemplate, e.CustomName, e.Type)
}

func (e *EcUnit) GenerateBenchmarkMethod() string {
	return fmt.Sprintf(Benchmark, e.CustomName, e.Type)
}

func (e *EcUnit) GenerateTestMethod() string {
	return fmt.Sprintf(TestTemplate, e.CustomName, e.Type)
}

func GetData(src string) (ecUnits []EcUnit, packageName string) {
	return ecUnits, packageName
}

type Generated struct {
	Package string
	EcUnits []*EcUnit
}

func (g *Generated) genHeadComment() string {
	return "//generated by efaceconv DO NOT EDIT!\n"
}

func (g *Generated) genPackage() string {
	return "package " + g.Package + "\n\n"
}

func (g *Generated) genImport(test bool) string {
	imports := "import (\n"
	if test {
		imports += "  \"reflect\"\n"
		imports += "  \"testing\"\n"
	} else {
		imports += "  \"github.com/t0pep0/efaceconv/ecutils\"\n"
	}
	for _, unit := range g.EcUnits {
		if unit.Import != "" {
			imports += "  \"" + unit.GenerateImport() + "\"\n"
		}
	}
	imports += ")\n\n"
	return imports
}

func (g *Generated) genVars() string {
	vars := "var (\n"
	for _, unit := range g.EcUnits {
		vars += "  " + unit.GenerateVarForTDPointer() + "\n"
	}
	vars += ")\n\n"
	return vars
}

func (g *Generated) genInit() string {
	init := "func init(){\n"
	for _, unit := range g.EcUnits {
		init += "  " + unit.GenerateInit() + "\n\n"
	}
	init += "}\n\n"
	return init
}

func (g *Generated) genBody() string {
	var body string
	for _, unit := range g.EcUnits {
		body += unit.GenerateConvMethod()
	}
	return body
}

func (g *Generated) GenSrc() string {
	var src string
	src += g.genHeadComment()
	src += g.genPackage()
	src += g.genImport(false)
	src += g.genVars()
	src += g.genInit()
	src += g.genBody()
	return src
}

func (g *Generated) GenTest() string {
	var src string
	src += g.genHeadComment()
	src += g.genPackage()
	src += g.genImport(true)
	for _, unit := range g.EcUnits {
		src += unit.GenerateTestMethod()
		src += unit.GenerateBenchmarkMethod()
	}
	return src
}

func ReadFile(name string) (units []*EcUnit, pkg string) {
	rx := regexp.MustCompile(`\/\/ec\:([a-zA-Z\.\/0-9]*)\:([a-zA-Z0-9\[\]]*)\:([a-zA-Z0-9]*)`)
	fset := token.NewFileSet()
	prs, err := parser.ParseFile(fset, name, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	pkg = prs.Name.String()
	for _, comments := range prs.Comments {
		for _, comment := range comments.List {
			match := rx.FindStringSubmatch(comment.Text)
			if len(match) == 4 {
				units = append(units, &EcUnit{Import: match[1], Type: match[2], CustomName: match[3]})
			}
		}
	}
	return units, pkg
}

func ReadDir(g *Generated) {
	curDir, err := os.Open(".")
	if err != nil {
		panic(err)
	}
	defer curDir.Close()
	files, err := curDir.Readdir(0)
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		if filepath.Ext(file.Name()) == ".go" && file.Name() != GenerateFileName && file.Name() != GenerateTestFileName {
			units, pkg := ReadFile(file.Name())
			g.Package = pkg
			g.EcUnits = append(g.EcUnits, units...)
		}
	}
}

const (
	GenerateFileName     = "efaceconv_generated.go"
	GenerateTestFileName = "efaceconv_generated_test.go"
)

func main() {
	g := new(Generated)
	ReadDir(g)
	gen, err := os.Create(GenerateFileName)
	if err != nil {
		panic(err)
	}
	defer gen.Close()
	genTest, err := os.Create(GenerateTestFileName)
	if err != nil {
		panic(err)
	}
	defer genTest.Close()
	fmt.Fprintf(gen, g.GenSrc())
	fmt.Fprintf(genTest, g.GenTest())
}
