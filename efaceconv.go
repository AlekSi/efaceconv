package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
)

type ecUnit struct {
	Import     string
	Type       string
	CustomName string
}

func (e *ecUnit) generateImport() string {
	return fmt.Sprintf("%v", e.Import)
}

func (e *ecUnit) generateVarForTDPointer() string {
	return fmt.Sprintf("_%vKind uintptr", e.CustomName)
}

func (e *ecUnit) generateInit() string {
	return fmt.Sprintf("var s%v %v\n  _%[1]vKind = ecutils.GetKind(s%[1]v)", e.CustomName, e.Type)
}

const methodTemplate = `
// Eface2%v returns pointer to %v and true if arg is a string
// or nil and false otherwise
func Eface2%[1]v(arg interface{}) (*%[2]v, bool) {
	if ecutils.GetKind(arg) == _%[1]vKind {
		return (*%[2]v)(ecutils.GetDataPtr(arg)), true
	}
	return nil, false
}

`

const testTemplate = `
func TestEface2%v(t *testing.T) {
  var %[1]v %v
	res, ok := Eface2%[1]v(%[1]v)
	if !ok {
		t.Error("Wrong type!")
	}
	if !reflect.DeepEqual(*res, %[1]v) {
		t.Error("Not equal")
	}
	_, ok = Eface2%[1]v(ok)
	if ok {
		t.Error("Wrong type!")
	}
}

`

const benchmark = `
func BenchmarkEface2%v(b *testing.B) {
  var %[1]v %[2]v
	var v *%[2]v
	var ok bool
	for n := 0; n < b.N; n++ {
		v, ok = Eface2%[1]v(%[1]v)
	}
	b.Log(v, ok) //For don't use compiler optimization
}

func _%[1]vClassic(arg interface{}) (v %[2]v, ok bool) {
	v, ok = arg.(%[2]v)
	return v, ok
}

func Benchmark%[1]vClassic(b *testing.B) {
  var %[1]v %[2]v
  var v %[2]v
	var ok bool
	for n := 0; n < b.N; n++ {
		v, ok = _%[1]vClassic(%[1]v)
	}
	b.Log(v, ok) //For don't use compiler optimization
}


`

func (e *ecUnit) generateConvMethod() string {
	return fmt.Sprintf(methodTemplate, e.CustomName, e.Type)
}

func (e *ecUnit) generatebenchmarkMethod() string {
	return fmt.Sprintf(benchmark, e.CustomName, e.Type)
}

func (e *ecUnit) generateTestMethod() string {
	return fmt.Sprintf(testTemplate, e.CustomName, e.Type)
}

type generated struct {
	Package string
	ecUnits []*ecUnit
}

func (g *generated) genHeadComment() string {
	return "//generated by efaceconv DO NOT EDIT!\n"
}

func (g *generated) genPackage() string {
	return "package " + g.Package + "\n\n"
}

func (g *generated) genImport(test bool) string {
	imports := "import (\n"
	if test {
		imports += "  \"reflect\"\n"
		imports += "  \"testing\"\n"
	} else {
		imports += "  \"github.com/t0pep0/efaceconv/ecutils\"\n"
	}
	for _, unit := range g.ecUnits {
		if unit.Import != "" {
			imports += "  \"" + unit.generateImport() + "\"\n"
		}
	}
	imports += ")\n\n"
	return imports
}

func (g *generated) genVars() string {
	vars := "var (\n"
	for _, unit := range g.ecUnits {
		vars += "  " + unit.generateVarForTDPointer() + "\n"
	}
	vars += ")\n\n"
	return vars
}

func (g *generated) genInit() string {
	init := "func init(){\n"
	for _, unit := range g.ecUnits {
		init += "  " + unit.generateInit() + "\n\n"
	}
	init += "}\n\n"
	return init
}

func (g *generated) genBody() string {
	var body string
	for _, unit := range g.ecUnits {
		body += unit.generateConvMethod()
	}
	return body
}

func (g *generated) GenSrc() string {
	var src string
	src += g.genHeadComment()
	src += g.genPackage()
	src += g.genImport(false)
	src += g.genVars()
	src += g.genInit()
	src += g.genBody()
	return src
}

func (g *generated) GenTest() string {
	var src string
	src += g.genHeadComment()
	src += g.genPackage()
	src += g.genImport(true)
	for _, unit := range g.ecUnits {
		src += unit.generateTestMethod()
		src += unit.generatebenchmarkMethod()
	}
	return src
}

func readFile(name string) (units []*ecUnit, pkg string) {
	rx := regexp.MustCompile(`\/\/ec\:([a-zA-Z\.\/0-9]*)\:([a-zA-Z0-9\[\]]*)\:([a-zA-Z0-9]*)`)
	fset := token.NewFileSet()
	prs, err := parser.ParseFile(fset, name, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	pkg = prs.Name.String()
	for _, comments := range prs.Comments {
		for _, comment := range comments.List {
			match := rx.FindStringSubmatch(comment.Text)
			if len(match) == 4 {
				units = append(units, &ecUnit{Import: match[1], Type: match[2], CustomName: match[3]})
			}
		}
	}
	return units, pkg
}

func readDir(g *generated) {
	curDir, err := os.Open(".")
	if err != nil {
		panic(err)
	}
	defer curDir.Close()
	files, err := curDir.Readdir(0)
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		if filepath.Ext(file.Name()) == ".go" && file.Name() != generateFileName && file.Name() != generateTestFileName {
			units, pkg := readFile(file.Name())
			g.Package = pkg
			g.ecUnits = append(g.ecUnits, units...)
		}
	}
}

const (
	generateFileName     = "efaceconv_generated.go"
	generateTestFileName = "efaceconv_generated_test.go"
)

func main() {
	g := new(generated)
	readDir(g)
	gen, err := os.Create(generateFileName)
	if err != nil {
		panic(err)
	}
	defer func() {
		gen.Close()
		exec.Command("goimports", "-w", generateFileName).Run()
		exec.Command("gofmt", "-w", "-s", generateFileName).Run()
	}()
	genTest, err := os.Create(generateTestFileName)
	if err != nil {
		panic(err)
	}
	defer genTest.Close()
	fmt.Fprintf(gen, g.GenSrc())
	fmt.Fprintf(genTest, g.GenTest())
}
